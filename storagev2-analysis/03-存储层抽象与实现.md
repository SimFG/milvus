# Milvus StorageV2 存储层抽象与实现

## 1. 概述

StorageV2 的存储层采用分层抽象设计，通过统一的接口支持多种存储后端。整个存储层从上到下分为：ChunkManager 抽象层、ObjectStorage 接口层、以及具体的存储实现层。

## 2. 存储层架构

### 2.1 分层架构图

```
┌─────────────────────────────────────────────────────┐
│                   Application Layer                │
│          (DataNode, QueryNode, IndexNode)         │
├─────────────────────────────────────────────────────┤
│                ChunkManager Interface              │
│  ┌─────────────────┐    ┌─────────────────────────┐  │
│  │ LocalChunkMgr   │    │  RemoteChunkManager    │  │
│  └─────────────────┘    └─────────────────────────┘  │
├─────────────────────────────────────────────────────┤
│                ObjectStorage Interface             │
│  ┌──────────────┐ ┌──────────────┐ ┌─────────────┐  │
│  │MinioObjectSto│ │AzureObjectSto│ │GcpObjectSto │  │
│  └──────────────┘ └──────────────┘ └─────────────┘  │
├─────────────────────────────────────────────────────┤
│                Physical Storage Layer              │
│  ┌──────────────┐ ┌──────────────┐ ┌─────────────┐  │
│  │   Local FS   │ │  AWS S3/     │ │  Azure Blob │  │
│  │              │ │  MinIO       │ │  / GCP      │  │
│  └──────────────┘ └──────────────┘ └─────────────┘  │
└─────────────────────────────────────────────────────┘
```

### 2.2 核心接口定义

#### 2.2.1 ChunkManager 接口
```go
type ChunkManager interface {
    // 基础操作
    RootPath() string
    Path(ctx context.Context, filePath string) (string, error)
    
    // 读写操作
    Reader(ctx context.Context, filePath string) (FileReader, error)
    Write(ctx context.Context, filePath string, content []byte) error
    MultiWrite(ctx context.Context, contents map[string][]byte) error
    
    // 查询操作
    Exist(ctx context.Context, filePath string) (bool, error)
    Read(ctx context.Context, filePath string) ([]byte, error)
    MultiRead(ctx context.Context, filePaths []string) ([][]byte, error)
    ReadAt(ctx context.Context, filePath string, off int64, length int64) ([]byte, error)
    Size(ctx context.Context, filePath string) (int64, error)
    
    // 高级操作
    Mmap(ctx context.Context, filePath string) (*mmap.ReaderAt, error)
    WalkWithPrefix(ctx context.Context, prefix string, recursive bool, walkFunc ChunkObjectWalkFunc) error
    
    // 删除操作
    Remove(ctx context.Context, filePath string) error
    MultiRemove(ctx context.Context, filePaths []string) error
    RemoveWithPrefix(ctx context.Context, prefix string) error
}
```

#### 2.2.2 ObjectStorage 接口
```go
type ObjectStorage interface {
    // 对象操作
    GetObject(ctx context.Context, bucketName, objectName string, offset int64, size int64) (FileReader, error)
    PutObject(ctx context.Context, bucketName, objectName string, reader io.Reader, objectSize int64) error
    StatObject(ctx context.Context, bucketName, objectName string) (int64, error)
    RemoveObject(ctx context.Context, bucketName, objectName string) error
    
    // 批量操作
    WalkWithObjects(ctx context.Context, bucketName string, prefix string, recursive bool, walkFunc ChunkObjectWalkFunc) error
}
```

## 3. ChunkManager 工厂模式

### 3.1 工厂设计

#### 3.1.1 ChunkManagerFactory 结构
```go
type ChunkManagerFactory struct {
    persistentStorage string                // 存储类型
    config            *objectstorage.Config // 配置信息
}

type Factory interface {
    NewPersistentStorageChunkManager(ctx context.Context) (ChunkManager, error)
}
```

#### 3.1.2 工厂方法实现
```go
func (f *ChunkManagerFactory) newChunkManager(ctx context.Context, engine string) (ChunkManager, error) {
    switch engine {
    case "local":
        return NewLocalChunkManager(objectstorage.RootPath(f.config.RootPath)), nil
    case "remote", "minio", "opendal":
        return NewRemoteChunkManager(ctx, f.config)
    default:
        return nil, errors.New("no chunk manager implemented with engine: " + engine)
    }
}
```

### 3.2 配置管理

#### 3.2.1 参数化工厂创建
```go
func NewChunkManagerFactoryWithParam(params *paramtable.ComponentParam) *ChunkManagerFactory {
    if params.CommonCfg.StorageType.GetValue() == "local" {
        return NewChunkManagerFactory("local", 
            objectstorage.RootPath(params.LocalStorageCfg.Path.GetValue()))
    }
    
    return NewChunkManagerFactory(
        params.CommonCfg.StorageType.GetValue(),
        objectstorage.RootPath(params.MinioCfg.RootPath.GetValue()),
        objectstorage.Address(params.MinioCfg.Address.GetValue()),
        objectstorage.AccessKeyID(params.MinioCfg.AccessKeyID.GetValue()),
        objectstorage.SecretAccessKeyID(params.MinioCfg.SecretAccessKey.GetValue()),
        objectstorage.UseSSL(params.MinioCfg.UseSSL.GetAsBool()),
        objectstorage.BucketName(params.MinioCfg.BucketName.GetValue()),
        objectstorage.UseIAM(params.MinioCfg.UseIAM.GetAsBool()),
        objectstorage.CloudProvider(params.MinioCfg.CloudProvider.GetValue()),
        objectstorage.Region(params.MinioCfg.Region.GetValue()),
        // ... 其他配置项
    )
}
```

#### 3.2.2 存储配置选项
```go
type Config struct {
    RootPath            string    // 根路径
    Address             string    // 服务地址
    AccessKeyID         string    // 访问密钥ID
    SecretAccessKeyID   string    // 访问密钥值
    UseSSL              bool      // 是否使用SSL
    BucketName          string    // 桶名称
    UseIAM              bool      // 是否使用IAM
    CloudProvider       string    // 云提供商
    IAMEndpoint         string    // IAM 端点
    Region              string    // 区域
    RequestTimeout      int64     // 请求超时
    UseVirtualHost      bool      // 虚拟主机模式
    CreateBucket        bool      // 是否创建桶
    GcpCredentialJSON   string    // GCP 凭证JSON
}
```

## 4. 本地存储实现

### 4.1 LocalChunkManager 结构

#### 4.1.1 基本结构
```go
type LocalChunkManager struct {
    localPath string  // 本地存储路径
}

var _ ChunkManager = (*LocalChunkManager)(nil)
```

#### 4.1.2 创建方法
```go
func NewLocalChunkManager(opts ...objectstorage.Option) *LocalChunkManager {
    c := objectstorage.NewDefaultConfig()
    for _, opt := range opts {
        opt(c)
    }
    return &LocalChunkManager{
        localPath: c.RootPath,
    }
}
```

### 4.2 基础文件操作

#### 4.2.1 读取操作
```go
// 基础读取
func (lcm *LocalChunkManager) Read(ctx context.Context, filePath string) ([]byte, error) {
    return ReadFile(filePath)
}

// 批量读取
func (lcm *LocalChunkManager) MultiRead(ctx context.Context, filePaths []string) ([][]byte, error) {
    results := make([][]byte, len(filePaths))
    var el error
    
    for i, filePath := range filePaths {
        content, err := lcm.Read(ctx, filePath)
        if err != nil {
            el = merr.Combine(el, errors.Wrapf(err, "failed to read %s", filePath))
        }
        results[i] = content
    }
    return results, el
}

// 定位读取
func (lcm *LocalChunkManager) ReadAt(ctx context.Context, filePath string, off int64, length int64) ([]byte, error) {
    if off < 0 || length < 0 {
        return nil, io.EOF
    }

    file, err := Open(path.Clean(filePath))
    if err != nil {
        return nil, err
    }
    defer file.Close()

    res := make([]byte, length)
    _, err = file.ReadAt(res, off)
    if err != nil {
        return nil, merr.WrapErrIoFailed(filePath, err)
    }
    return res, nil
}
```

#### 4.2.2 写入操作
```go
// 单文件写入
func (lcm *LocalChunkManager) Write(ctx context.Context, filePath string, content []byte) error {
    dir := path.Dir(filePath)
    exist, err := lcm.Exist(ctx, dir)
    if err != nil {
        return err
    }
    
    // 创建目录
    if !exist {
        err := os.MkdirAll(dir, os.ModePerm)
        if err != nil {
            return merr.WrapErrIoFailed(filePath, err)
        }
    }
    return WriteFile(filePath, content, os.ModePerm)
}

// 批量写入
func (lcm *LocalChunkManager) MultiWrite(ctx context.Context, contents map[string][]byte) error {
    var el error
    for filePath, content := range contents {
        err := lcm.Write(ctx, filePath, content)
        if err != nil {
            el = merr.Combine(el, errors.Wrapf(err, "write %s failed", filePath))
        }
    }
    return el
}
```

### 4.3 高级功能

#### 4.3.1 内存映射支持
```go
func (lcm *LocalChunkManager) Mmap(ctx context.Context, filePath string) (*mmap.ReaderAt, error) {
    reader, err := mmap.Open(path.Clean(filePath))
    if errors.Is(err, os.ErrNotExist) {
        return nil, merr.WrapErrIoKeyNotFound(filePath, err.Error())
    }
    return reader, merr.WrapErrIoFailed(filePath, err)
}
```

#### 4.3.2 前缀遍历
```go
func (lcm *LocalChunkManager) WalkWithPrefix(
    ctx context.Context, 
    prefix string, 
    recursive bool, 
    walkFunc ChunkObjectWalkFunc,
) error {
    if recursive {
        // 递归遍历
        dir := filepath.Dir(prefix)
        return filepath.Walk(dir, func(filePath string, f os.FileInfo, err error) error {
            if ctx.Err() != nil {
                return ctx.Err()
            }
            if err != nil {
                return err
            }

            if strings.HasPrefix(filePath, prefix) && !f.IsDir() {
                if !walkFunc(&ChunkObjectInfo{
                    FilePath: filePath, 
                    ModifyTime: f.ModTime(),
                }) {
                    return nil
                }
            }
            return nil
        })
    }

    // 非递归遍历
    globPaths, err := filepath.Glob(prefix + "*")
    if err != nil {
        return err
    }
    
    for _, filePath := range globPaths {
        if ctx.Err() != nil {
            return ctx.Err()
        }

        f, err := os.Stat(filePath)
        if err != nil {
            if errors.Is(err, os.ErrNotExist) {
                return merr.WrapErrIoKeyNotFound(filePath)
            }
            return merr.WrapErrIoFailed(filePath, err)
        }
        
        if !walkFunc(&ChunkObjectInfo{
            FilePath: filePath, 
            ModifyTime: f.ModTime(),
        }) {
            return nil
        }
    }
    return nil
}
```

### 4.4 LocalReader 实现

#### 4.4.1 Reader 结构
```go
type LocalReader struct {
    *os.File
}

func (lr *LocalReader) Size() (int64, error) {
    stat, err := lr.Stat()
    if err != nil {
        return -1, nil
    }
    return stat.Size(), nil
}
```

## 5. 远程存储实现

### 5.1 RemoteChunkManager 结构

#### 5.1.1 基本结构
```go
type RemoteChunkManager struct {
    client     ObjectStorage  // 对象存储客户端
    bucketName string         // 桶名称
    rootPath   string         // 根路径
}

var _ ChunkManager = (*RemoteChunkManager)(nil)
```

#### 5.1.2 创建方法
```go
func NewRemoteChunkManager(ctx context.Context, c *objectstorage.Config) (*RemoteChunkManager, error) {
    var client ObjectStorage
    var err error
    
    // 根据云提供商选择客户端
    if c.CloudProvider == objectstorage.CloudProviderAzure {
        client, err = newAzureObjectStorageWithConfig(ctx, c)
    } else if c.CloudProvider == objectstorage.CloudProviderGCPNative {
        client, err = newGcpNativeObjectStorageWithConfig(ctx, c)
    } else {
        client, err = newMinioObjectStorageWithConfig(ctx, c)
    }
    
    if err != nil {
        return nil, err
    }
    
    mcm := &RemoteChunkManager{
        client:     client,
        bucketName: c.BucketName,
        rootPath:   strings.TrimLeft(c.RootPath, "/"),
    }
    
    log.Info("remote chunk manager init success.", 
        zap.String("remote", c.CloudProvider), 
        zap.String("bucketname", c.BucketName), 
        zap.String("root", mcm.RootPath()))
    return mcm, nil
}
```

### 5.2 远程存储操作

#### 5.2.1 读取操作
```go
func (rcm *RemoteChunkManager) Read(ctx context.Context, filePath string) ([]byte, error) {
    reader, err := rcm.client.GetObject(ctx, rcm.bucketName, filePath, 0, -1)
    if err != nil {
        return nil, err
    }
    defer reader.Close()

    return io.ReadAll(reader)
}

func (rcm *RemoteChunkManager) ReadAt(ctx context.Context, filePath string, off int64, length int64) ([]byte, error) {
    if off < 0 || length < 0 {
        return nil, io.EOF
    }

    reader, err := rcm.client.GetObject(ctx, rcm.bucketName, filePath, off, length)
    if err != nil {
        return nil, err
    }
    defer reader.Close()

    return io.ReadAll(reader)
}
```

#### 5.2.2 写入操作
```go
func (rcm *RemoteChunkManager) Write(ctx context.Context, filePath string, content []byte) error {
    reader := bytes.NewReader(content)
    return rcm.client.PutObject(ctx, rcm.bucketName, filePath, reader, int64(len(content)))
}

func (rcm *RemoteChunkManager) MultiWrite(ctx context.Context, contents map[string][]byte) error {
    var eg errgroup.Group
    eg.SetLimit(10) // 限制并发数
    
    var el error
    for filePath, content := range contents {
        filePath := filePath
        content := content
        eg.Go(func() error {
            err := rcm.Write(ctx, filePath, content)
            if err != nil {
                el = merr.Combine(el, errors.Wrapf(err, "write %s failed", filePath))
            }
            return nil
        })
    }
    
    eg.Wait()
    return el
}
```

## 6. 对象存储抽象

### 6.1 MinIO 对象存储

#### 6.1.1 MinioObjectStorage 结构
```go
type MinioObjectStorage struct {
    *minio.Client
}

func (m *MinioObjectStorage) GetObject(
    ctx context.Context, 
    bucketName, objectName string, 
    offset int64, 
    size int64,
) (FileReader, error) {
    opts := minio.GetObjectOptions{}
    if offset > 0 {
        err := opts.SetRange(offset, offset+size-1)
        if err != nil {
            return nil, err
        }
    }
    
    object, err := m.Client.GetObject(ctx, bucketName, objectName, opts)
    if err != nil {
        return nil, err
    }
    
    return &minioReader{object}, nil
}
```

#### 6.1.2 上传实现
```go
func (m *MinioObjectStorage) PutObject(
    ctx context.Context, 
    bucketName, objectName string, 
    reader io.Reader, 
    objectSize int64,
) error {
    _, err := m.Client.PutObject(
        ctx, 
        bucketName, 
        objectName, 
        reader, 
        objectSize,
        minio.PutObjectOptions{},
    )
    return err
}
```

### 6.2 Azure Blob 存储

#### 6.2.1 AzureObjectStorage 结构
```go
type AzureObjectStorage struct {
    client *azblob.Client
}

func (a *AzureObjectStorage) GetObject(
    ctx context.Context, 
    bucketName, objectName string, 
    offset int64, 
    size int64,
) (FileReader, error) {
    var httpRange *azblob.HTTPRange
    if offset > 0 {
        count := size
        if size < 0 {
            count = azblob.CountToEnd
        }
        httpRange = &azblob.HTTPRange{
            Offset: offset,
            Count:  count,
        }
    }
    
    response, err := a.client.DownloadStream(
        ctx, 
        bucketName, 
        objectName,
        &azblob.DownloadStreamOptions{
            Range: httpRange,
        },
    )
    if err != nil {
        return nil, err
    }
    
    return &azureReader{response.Body}, nil
}
```

### 6.3 GCP 存储

#### 6.3.1 GcpObjectStorage 结构
```go
type GcpObjectStorage struct {
    client *storage.Client
}

func (g *GcpObjectStorage) GetObject(
    ctx context.Context, 
    bucketName, objectName string, 
    offset int64, 
    size int64,
) (FileReader, error) {
    obj := g.client.Bucket(bucketName).Object(objectName)
    
    reader, err := obj.NewRangeReader(ctx, offset, size)
    if err != nil {
        return nil, err
    }
    
    return &gcpReader{reader}, nil
}
```

## 7. C++ 存储层集成

### 7.1 ChunkManager C++ 接口

#### 7.1.1 抽象基类
```cpp
namespace milvus::storage {

class ChunkManager {
public:
    virtual bool Exist(const std::string& filepath) = 0;
    virtual uint64_t Size(const std::string& filepath) = 0;
    virtual uint64_t Read(const std::string& filepath, void* buf, uint64_t len) = 0;
    virtual void Write(const std::string& filepath, void* buf, uint64_t len) = 0;
    virtual uint64_t Read(const std::string& filepath, uint64_t offset, void* buf, uint64_t len) = 0;
    virtual void Write(const std::string& filepath, uint64_t offset, void* buf, uint64_t len) = 0;
    virtual std::vector<std::string> ListWithPrefix(const std::string& filepath) = 0;
    virtual void Remove(const std::string& filepath) = 0;
    virtual std::string GetName() const = 0;
    virtual std::string GetRootPath() const = 0;
};

enum class ChunkManagerType : int8_t {
    None = 0,
    Local = 1,
    Minio = 2,
    Remote = 3,
    OpenDAL = 4,
};

extern std::map<std::string, ChunkManagerType> ChunkManagerType_Map;

}  // namespace milvus::storage
```

#### 7.1.2 本地存储实现
```cpp
class LocalChunkManager : public ChunkManager {
public:
    explicit LocalChunkManager(const std::string& path) : path_prefix_(path) {}

    virtual bool Exist(const std::string& filepath) override;
    virtual uint64_t Size(const std::string& filepath) override;
    virtual uint64_t Read(const std::string& filepath, void* buf, uint64_t len) override;
    virtual void Write(const std::string& filepath, void* buf, uint64_t len) override;
    virtual uint64_t Read(const std::string& filepath, uint64_t offset, void* buf, uint64_t len) override;
    virtual void Write(const std::string& filepath, uint64_t offset, void* buf, uint64_t len) override;
    virtual std::vector<std::string> ListWithPrefix(const std::string& filepath) override;
    virtual void Remove(const std::string& filepath) override;
    virtual std::string GetName() const override { return "LocalChunkManager"; }
    virtual std::string GetRootPath() const override { return path_prefix_; }

    // 本地特有方法
    bool CreateFile(const std::string& filepath);
    bool DirExist(const std::string& dir);
    void RemoveDir(const std::string& dir);
    void CreateDir(const std::string& dir);
    int64_t GetSizeOfDir(const std::string& dir);

private:
    std::string path_prefix_;
};
```

### 7.2 远程存储实现

#### 7.2.1 MinIO C++ 客户端
```cpp
class MinioChunkManager : public ChunkManager {
public:
    MinioChunkManager(const StorageConfig& storage_config);
    virtual ~MinioChunkManager();

    virtual bool Exist(const std::string& filepath) override;
    virtual uint64_t Size(const std::string& filepath) override;
    virtual uint64_t Read(const std::string& filepath, void* buf, uint64_t len) override;
    virtual void Write(const std::string& filepath, void* buf, uint64_t len) override;
    // ... 其他接口实现

private:
    std::unique_ptr<Aws::S3::S3Client> client_;
    std::string bucket_name_;
    std::string root_path_;
};
```

## 8. 性能优化策略

### 8.1 并发控制

#### 8.1.1 批量操作优化
```go
func (rcm *RemoteChunkManager) MultiRead(ctx context.Context, filePaths []string) ([][]byte, error) {
    results := make([][]byte, len(filePaths))
    var eg errgroup.Group
    eg.SetLimit(10) // 限制并发数
    
    for i, filePath := range filePaths {
        i, filePath := i, filePath
        eg.Go(func() error {
            content, err := rcm.Read(ctx, filePath)
            if err != nil {
                return err
            }
            results[i] = content
            return nil
        })
    }
    
    if err := eg.Wait(); err != nil {
        return nil, err
    }
    return results, nil
}
```

### 8.2 缓存策略

#### 8.2.1 元数据缓存
- 文件大小缓存
- 存在性检查缓存
- 目录结构缓存

#### 8.2.2 数据缓存
- 热点数据本地缓存
- LRU 淘汰策略
- 缓存一致性保证

### 8.3 错误处理和重试

#### 8.3.1 重试机制
```go
func (rcm *RemoteChunkManager) ReadWithRetry(ctx context.Context, filePath string) ([]byte, error) {
    var result []byte
    var err error
    
    retryFunc := func() error {
        result, err = rcm.Read(ctx, filePath)
        return err
    }
    
    return result, retry.Do(ctx, retryFunc, 
        retry.Attempts(3),
        retry.Sleep(time.Second),
        retry.LastErrorOnly(true))
}
```

#### 8.3.2 错误分类处理
- 网络错误：自动重试
- 权限错误：立即失败
- 文件不存在：返回特定错误
- 服务端错误：指数退避重试

## 9. 监控和诊断

### 9.1 性能指标

#### 9.1.1 操作延迟监控
```go
func (rcm *RemoteChunkManager) ReadWithMetrics(ctx context.Context, filePath string) ([]byte, error) {
    start := time.Now()
    defer func() {
        duration := time.Since(start)
        metrics.StorageOperationDuration.WithLabelValues("read", "remote").Observe(duration.Seconds())
    }()
    
    return rcm.Read(ctx, filePath)
}
```

#### 9.1.2 错误率统计
- 按操作类型统计
- 按存储后端统计
- 按错误类型统计

### 9.2 调试工具

#### 9.2.1 存储健康检查
```go
func (rcm *RemoteChunkManager) HealthCheck(ctx context.Context) error {
    // 测试连接性
    testFile := "health_check_" + uuid.New().String()
    testData := []byte("health check")
    
    // 写入测试
    if err := rcm.Write(ctx, testFile, testData); err != nil {
        return fmt.Errorf("write health check failed: %w", err)
    }
    
    // 读取测试
    if data, err := rcm.Read(ctx, testFile); err != nil {
        return fmt.Errorf("read health check failed: %w", err)
    } else if !bytes.Equal(data, testData) {
        return fmt.Errorf("data integrity check failed")
    }
    
    // 清理测试文件
    return rcm.Remove(ctx, testFile)
}
```

StorageV2 的存储层抽象通过统一的接口设计和多种存储后端支持，为 Milvus 提供了灵活、可扩展的存储基础设施，满足了不同部署环境和性能需求。