# Milvus Streaming 故障恢复与高可用机制

## 1. 概述

Milvus Streaming 服务的高可用机制包括：
- WAL 检查点机制
- 自动故障检测与恢复
- 数据一致性保证
- 优雅降级与恢复
- 分布式协调与容错

## 2. 检查点机制

### 2.1 WAL 检查点结构

```go
type WALCheckpoint struct {
    MessageID message.MessageID  // 消息 ID
    TimeTick  uint64             // 时间戳
    Magic     int64              // 恢复魔术值
}

const (
    RecoveryMagicStreamingInitialized int64 = 1  // VChannel 信息已设置
)
```

### 2.2 检查点管理

```go
func (c *WALCheckpoint) IntoProto() *streamingpb.WALCheckpoint {
    return &streamingpb.WALCheckpoint{
        MessageId: &messagespb.MessageID{
            Id: c.MessageID.Marshal(),
        },
        TimeTick:      c.TimeTick,
        RecoveryMagic: c.Magic,
    }
}

func (c *WALCheckpoint) Clone() *WALCheckpoint {
    return &WALCheckpoint{
        MessageID: c.MessageID,
        TimeTick:  c.TimeTick,
        Magic:     c.Magic,
    }
}
```

### 2.3 检查点持久化

检查点定期保存到 etcd 中，包含：
- 当前处理的消息位置
- 时间戳信息
- 恢复状态标记

## 3. 恢复机制设计

### 3.1 恢复快照

```go
type RecoverySnapshot struct {
    VChannels          map[string]*streamingpb.VChannelMeta      // VChannel 元数据
    SegmentAssignments map[int64]*streamingpb.SegmentAssignmentMeta // 段分配信息
    Checkpoint         *WALCheckpoint                             // 检查点
    TxnBuffer          *utility.TxnBuffer                        // 事务缓冲
}
```

### 3.2 恢复流接口

```go
type RecoveryStream interface {
    // 返回恢复消息的通道
    Chan() <-chan message.ImmutableMessage
    
    // 获取恢复过程中的错误
    Error() error
    
    // 获取未提交的事务缓冲
    TxnBuffer() *utility.TxnBuffer
    
    // 关闭恢复流
    Close() error
}
```

### 3.3 恢复流构建器

```go
type RecoveryStreamBuilder interface {
    // WAL 名称
    WALName() string
    
    // Channel 信息
    Channel() types.PChannelInfo
    
    // 构建恢复流
    Build(param BuildRecoveryStreamParam) RecoveryStream
    
    // 获取底层 WAL 实现
    RWWALImpls() walimpls.WALImpls
}

type BuildRecoveryStreamParam struct {
    StartCheckpoint message.MessageID  // 起始检查点
    EndTimeTick     uint64             // 结束时间戳
}
```

## 4. 故障检测机制

### 4.1 节点健康检查

```go
type HealthChecker struct {
    nodes       map[int64]*NodeHealth
    checkPeriod time.Duration
    timeout     time.Duration
}

type NodeHealth struct {
    NodeID      int64
    LastPing    time.Time
    ConsecutiveFails int
    State       HealthState
}

type HealthState int32
const (
    HealthStateHealthy   HealthState = 0
    HealthStateUnhealthy HealthState = 1
    HealthStateDead      HealthState = 2
)
```

### 4.2 心跳机制

```go
func (hc *HealthChecker) Start(ctx context.Context) {
    ticker := time.NewTicker(hc.checkPeriod)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            hc.checkAllNodes(ctx)
        }
    }
}

func (hc *HealthChecker) checkAllNodes(ctx context.Context) {
    for nodeID, health := range hc.nodes {
        go func(nodeID int64, health *NodeHealth) {
            if err := hc.pingNode(ctx, nodeID); err != nil {
                hc.handleNodeUnhealthy(nodeID, err)
            } else {
                hc.handleNodeHealthy(nodeID)
            }
        }(nodeID, health)
    }
}
```

### 4.3 故障检测策略

1. **连续失败阈值**：连续 N 次检查失败才认为节点故障
2. **超时检测**：请求超时时间配置
3. **自适应检测**：根据历史表现调整检测频率

## 5. 自动故障恢复

### 5.1 WAL 恢复流程

```go
func RecoverWAL(ctx context.Context, 
               channel types.PChannelInfo,
               builder RecoveryStreamBuilder) (*WAL, error) {
    
    // 1. 加载检查点
    checkpoint, err := loadCheckpoint(ctx, channel)
    if err != nil {
        return nil, err
    }
    
    // 2. 构建恢复流
    param := BuildRecoveryStreamParam{
        StartCheckpoint: checkpoint.MessageID,
        EndTimeTick:     getCurrentTimeTick(),
    }
    recoveryStream := builder.Build(param)
    defer recoveryStream.Close()
    
    // 3. 重放消息
    if err := replayMessages(ctx, recoveryStream); err != nil {
        return nil, err
    }
    
    // 4. 恢复事务状态
    txnBuffer := recoveryStream.TxnBuffer()
    if err := restoreTransactions(ctx, txnBuffer); err != nil {
        return nil, err
    }
    
    // 5. 创建新的 WAL 实例
    return createWAL(ctx, channel, builder.RWWALImpls())
}
```

### 5.2 消息重放

```go
func replayMessages(ctx context.Context, stream RecoveryStream) error {
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
            
        case msg, ok := <-stream.Chan():
            if !ok {
                // 流结束
                return stream.Error()
            }
            
            // 处理消息
            if err := processRecoveryMessage(ctx, msg); err != nil {
                return err
            }
        }
    }
}

func processRecoveryMessage(ctx context.Context, 
                           msg message.ImmutableMessage) error {
    switch msg.MessageType() {
    case message.MessageTypeInsert:
        return handleInsertRecovery(ctx, msg)
    case message.MessageTypeDelete:
        return handleDeleteRecovery(ctx, msg)
    case message.MessageTypeCreateCollection:
        return handleCreateCollectionRecovery(ctx, msg)
    case message.MessageTypeDropCollection:
        return handleDropCollectionRecovery(ctx, msg)
    default:
        // 跳过不需要恢复的消息类型
        return nil
    }
}
```

### 5.3 事务状态恢复

```go
func restoreTransactions(ctx context.Context, 
                        txnBuffer *utility.TxnBuffer) error {
    
    // 获取所有未提交的事务
    uncommittedTxns := txnBuffer.GetUncommittedTransactions()
    
    for _, txn := range uncommittedTxns {
        switch txn.State {
        case TxnStateActive:
            // 回滚活跃事务
            if err := rollbackTransaction(ctx, txn.ID); err != nil {
                return err
            }
            
        case TxnStateCommitting:
            // 尝试完成提交
            if err := completeCommit(ctx, txn.ID); err != nil {
                // 提交失败，回滚
                return rollbackTransaction(ctx, txn.ID)
            }
            
        case TxnStateAborting:
            // 完成回滚
            if err := completeRollback(ctx, txn.ID); err != nil {
                return err
            }
        }
    }
    
    return nil
}
```

## 6. Channel 故障转移

### 6.1 故障检测与切换

```go
func (b *balancerImpl) handleNodeFailure(nodeID int64) error {
    // 1. 获取故障节点上的所有 Channel
    failedChannels := b.channelManager.GetNodeChannels(nodeID)
    
    // 2. 选择目标节点
    targetAssignments := make(map[ChannelID]*types.PChannelInfoAssigned)
    
    for _, channel := range failedChannels {
        // 选择健康的节点
        targetNode := b.selectHealthyNode(channel)
        if targetNode == nil {
            return errors.New("no healthy node available")
        }
        
        targetAssignments[channel.ChannelID()] = &types.PChannelInfoAssigned{
            Channel: channel.ChannelInfo(),
            Node:    targetNode.ToStreamingNodeInfo(),
        }
    }
    
    // 3. 执行故障转移
    return b.channelManager.AssignPChannels(context.Background(), targetAssignments)
}
```

### 6.2 优雅切换

```go
func (b *balancerImpl) gracefulFailover(
    ctx context.Context,
    channelID ChannelID,
    fromNode, toNode int64) error {
    
    // 1. 停止向故障节点发送新消息
    if err := b.stopTrafficToNode(fromNode, channelID); err != nil {
        log.Warn("failed to stop traffic", zap.Error(err))
    }
    
    // 2. 等待故障节点处理完未完成的消息
    if err := b.drainNodeMessages(ctx, fromNode, channelID); err != nil {
        log.Warn("failed to drain messages", zap.Error(err))
    }
    
    // 3. 在目标节点恢复 Channel
    if err := b.recoverChannelOnNode(ctx, toNode, channelID); err != nil {
        return err
    }
    
    // 4. 重定向流量到新节点
    return b.redirectTraffic(channelID, toNode)
}
```

## 7. 数据一致性保证

### 7.1 Term 机制防脑裂

```go
type PChannelInfo struct {
    Name       string
    Term       int64        // 任期号
    AccessMode AccessMode
}

func (w *walAdaptorImpl) Append(ctx context.Context, 
                               msg message.MutableMessage) (*AppendResult, error) {
    // 检查是否被隔离
    if w.isFenced.Load() {
        return nil, status.NewChannelFenced(w.Channel().String())
    }
    
    // 设置当前 Term
    msg = msg.WithWALTerm(w.Channel().Term)
    
    return w.doAppend(ctx, msg)
}
```

### 7.2 因果一致性

```go
type CausalConsistencyManager struct {
    vectorClock map[string]uint64  // 向量时钟
    mu          sync.RWMutex
}

func (ccm *CausalConsistencyManager) UpdateClock(
    source string, timestamp uint64) {
    
    ccm.mu.Lock()
    defer ccm.mu.Unlock()
    
    if ccm.vectorClock[source] < timestamp {
        ccm.vectorClock[source] = timestamp
    }
}

func (ccm *CausalConsistencyManager) CanDeliver(
    msg message.ImmutableMessage) bool {
    
    ccm.mu.RLock()
    defer ccm.mu.RUnlock()
    
    // 检查因果关系
    for source, requiredTS := range msg.Dependencies() {
        if ccm.vectorClock[source] < requiredTS {
            return false
        }
    }
    
    return true
}
```

### 7.3 MVCC 一致性

```go
func (mvcc *MVCCManager) ReadWithConsistency(
    vchannel string, 
    readTS uint64) ([]message.ImmutableMessage, error) {
    
    // 1. 检查读时间戳是否安全
    currentMVCC := mvcc.GetMVCCOfVChannel(vchannel)
    if readTS > currentMVCC.Timetick {
        return nil, errors.New("read timestamp too new")
    }
    
    // 2. 读取快照数据
    messages := mvcc.readSnapshot(vchannel, readTS)
    
    // 3. 过滤已删除的数据
    return mvcc.filterDeleted(messages, readTS), nil
}
```

## 8. 优雅降级机制

### 8.1 过载保护

```go
type LoadShedder struct {
    threshold    float64  // 负载阈值
    dropRate     float64  // 丢弃率
    currentLoad  float64  // 当前负载
}

func (ls *LoadShedder) ShouldDrop(req Request) bool {
    if ls.currentLoad < ls.threshold {
        return false
    }
    
    // 基于优先级丢弃
    if req.Priority() == PriorityLow {
        return rand.Float64() < ls.dropRate
    }
    
    return false
}
```

### 8.2 限流机制

```go
type RateLimiter struct {
    limiter *rate.Limiter
    burst   int
}

func (rl *RateLimiter) Allow(ctx context.Context) error {
    if !rl.limiter.Allow() {
        return status.NewResourceExhausted("rate limit exceeded")
    }
    return nil
}

func (rl *RateLimiter) Wait(ctx context.Context) error {
    return rl.limiter.Wait(ctx)
}
```

### 8.3 熔断器

```go
type CircuitBreaker struct {
    state        CircuitState
    failureCount int
    lastFailTime time.Time
    timeout      time.Duration
    threshold    int
}

type CircuitState int
const (
    CircuitClosed CircuitState = iota
    CircuitOpen
    CircuitHalfOpen
)

func (cb *CircuitBreaker) Call(fn func() error) error {
    if cb.state == CircuitOpen {
        if time.Since(cb.lastFailTime) > cb.timeout {
            cb.state = CircuitHalfOpen
        } else {
            return errors.New("circuit breaker is open")
        }
    }
    
    err := fn()
    if err != nil {
        cb.recordFailure()
    } else {
        cb.recordSuccess()
    }
    
    return err
}
```

## 9. 监控与告警

### 9.1 健康指标

```go
type HealthMetrics struct {
    // 节点状态
    NodeHealthy   prometheus.GaugeVec
    NodeUnhealthy prometheus.GaugeVec
    
    // 恢复指标
    RecoveryDuration prometheus.Histogram
    RecoverySuccess  prometheus.Counter
    RecoveryFailure  prometheus.Counter
    
    // 故障转移
    FailoverCount    prometheus.Counter
    FailoverDuration prometheus.Histogram
}
```

### 9.2 告警规则

```yaml
groups:
- name: streaming.rules
  rules:
  - alert: NodeDown
    expr: streaming_node_healthy == 0
    for: 30s
    labels:
      severity: critical
    annotations:
      summary: "Streaming node is down"
      
  - alert: HighRecoveryLatency
    expr: streaming_recovery_duration_seconds > 60
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Recovery taking too long"
      
  - alert: FrequentFailover
    expr: rate(streaming_failover_count[5m]) > 0.1
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "Frequent failover detected"
```

## 10. 最佳实践

### 10.1 容错配置

```yaml
streaming:
  recovery:
    # 检查点间隔
    checkpointInterval: 5s
    
    # 恢复超时
    recoveryTimeout: 300s
    
    # 最大重试次数
    maxRetries: 3
    
  failover:
    # 故障检测间隔
    healthCheckInterval: 10s
    
    # 故障阈值
    failureThreshold: 3
    
    # 恢复时间
    recoveryTime: 30s
```

### 10.2 部署建议

1. **多区域部署**：跨可用区部署避免单点故障
2. **资源预留**：预留足够资源应对故障转移
3. **监控完善**：完善的监控和告警体系
4. **演练测试**：定期进行故障演练

### 10.3 运维流程

1. **故障响应**：自动化故障检测和处理
2. **手动干预**：紧急情况下的手动故障转移
3. **数据备份**：定期备份关键元数据
4. **容量规划**：基于监控数据进行容量规划