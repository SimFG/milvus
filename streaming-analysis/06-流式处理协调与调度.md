# Milvus Streaming 流式处理协调与调度机制

## 1. 概述

Milvus Streaming 的协调与调度机制负责：
- 节点间的任务分配和负载均衡
- 流处理拓扑的动态调整
- 资源的优化利用
- 系统的弹性伸缩

## 2. 负载均衡架构

### 2.1 Balancer 核心设计

```go
type balancerImpl struct {
    channelManager *channel.ChannelManager
    nodeManager    *NodeManager
    policy         BalancePolicy
    
    // 调度控制
    rebalanceTrigger chan struct{}
    rebalanceTimer   *time.Timer
    lastRebalanceTime time.Time
    
    // 监控
    metrics *balancerMetrics
}
```

### 2.2 负载均衡策略接口

```go
type BalancePolicy interface {
    // 计算期望的分配布局
    ComputeExpectedLayout(
        currentView *PChannelView,
        nodeView *NodeView,
    ) ExpectedLayout
    
    // 评估当前分配的健康度
    EvaluateBalance(layout ExpectedLayout) float64
    
    // 策略名称
    Name() string
}
```

## 3. VChannel Fair 策略实现

### 3.1 策略结构

```go
type VChannelFairPolicy struct {
    // 期望每个节点的 Channel 数量均衡
    targetChannelsPerNode int
    
    // 亲和性配置
    affinityEnabled bool
    affinityDecay   float64
}
```

### 3.2 分配算法

```go
func (p *VChannelFairPolicy) ComputeExpectedLayout(
    currentView *PChannelView,
    nodeView *NodeView) ExpectedLayout {
    
    // 1. 计算每个节点应分配的 Channel 数
    totalChannels := len(currentView.Channels)
    activeNodes := nodeView.GetActiveNodes()
    avgChannelsPerNode := totalChannels / len(activeNodes)
    
    // 2. 构建分配方案
    layout := NewExpectedLayout()
    
    // 3. 优先保持现有分配（亲和性）
    for channelID, channel := range currentView.Channels {
        if channel.IsAssigned() && nodeView.IsNodeActive(channel.CurrentServerID()) {
            if p.shouldKeepAssignment(channel, avgChannelsPerNode) {
                layout.Add(channelID, channel.CurrentServerID())
            }
        }
    }
    
    // 4. 分配未分配的 Channel
    unassignedChannels := p.getUnassignedChannels(currentView, layout)
    underloadedNodes := p.getUnderloadedNodes(nodeView, layout, avgChannelsPerNode)
    
    for _, channelID := range unassignedChannels {
        if len(underloadedNodes) == 0 {
            break
        }
        
        // 选择负载最低的节点
        nodeID := underloadedNodes[0]
        layout.Add(channelID, nodeID)
        
        // 更新节点负载
        if layout.GetNodeChannelCount(nodeID) >= avgChannelsPerNode {
            underloadedNodes = underloadedNodes[1:]
        }
    }
    
    return layout
}
```

### 3.3 亲和性计算

```go
func (p *VChannelFairPolicy) calculateAffinity(
    channel *PChannelMeta,
    nodeID int64) float64 {
    
    if !p.affinityEnabled {
        return 0
    }
    
    // 基于历史分配计算亲和性
    affinity := 0.0
    for _, history := range channel.AssignHistories() {
        if history.Node.ServerID == nodeID {
            // 时间衰减
            age := time.Since(history.Timestamp).Hours()
            affinity += math.Exp(-age * p.affinityDecay)
        }
    }
    
    return affinity
}
```

## 4. 节点管理

### 4.1 NodeManager 设计

```go
type NodeManager struct {
    mu sync.RWMutex
    nodes map[int64]*NodeInfo
    
    // 健康检查
    healthChecker *HealthChecker
    
    // 节点发现
    discoverer *NodeDiscoverer
}

type NodeInfo struct {
    ServerID   int64
    Address    string
    State      NodeState
    Capacity   NodeCapacity
    LastSeen   time.Time
    Metrics    NodeMetrics
}
```

### 4.2 节点状态管理

```go
type NodeState int32

const (
    NodeStateUnknown   NodeState = 0
    NodeStateHealthy   NodeState = 1
    NodeStateUnhealthy NodeState = 2
    NodeStateOffline   NodeState = 3
)

func (nm *NodeManager) UpdateNodeState(nodeID int64, state NodeState) {
    nm.mu.Lock()
    defer nm.mu.Unlock()
    
    if node, ok := nm.nodes[nodeID]; ok {
        oldState := node.State
        node.State = state
        node.LastSeen = time.Now()
        
        // 触发状态变更事件
        if oldState != state {
            nm.onNodeStateChanged(nodeID, oldState, state)
        }
    }
}
```

### 4.3 容量评估

```go
type NodeCapacity struct {
    MaxChannels     int     // 最大 Channel 数
    CPUCores        int     // CPU 核心数
    MemoryGB        int     // 内存大小
    NetworkBandMbps int     // 网络带宽
}

func (nm *NodeManager) GetNodeScore(nodeID int64) float64 {
    nm.mu.RLock()
    defer nm.mu.RUnlock()
    
    node, ok := nm.nodes[nodeID]
    if !ok || node.State != NodeStateHealthy {
        return 0
    }
    
    // 综合评分
    cpuScore := 1.0 - node.Metrics.CPUUsage
    memScore := 1.0 - node.Metrics.MemoryUsage
    netScore := 1.0 - node.Metrics.NetworkUsage
    
    // 加权平均
    return 0.4*cpuScore + 0.4*memScore + 0.2*netScore
}
```

## 5. 调度执行流程

### 5.1 触发机制

```go
func (b *balancerImpl) Start(ctx context.Context) {
    // 定期检查
    ticker := time.NewTicker(b.config.CheckInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return
            
        case <-ticker.C:
            b.checkAndRebalance(ctx)
            
        case <-b.rebalanceTrigger:
            b.checkAndRebalance(ctx)
        }
    }
}

func (b *balancerImpl) checkAndRebalance(ctx context.Context) {
    // 1. 检查是否需要重平衡
    if !b.shouldRebalance() {
        return
    }
    
    // 2. 计算新的分配方案
    currentView := b.channelManager.CurrentPChannelsView()
    nodeView := b.nodeManager.GetNodeView()
    
    expectedLayout := b.policy.ComputeExpectedLayout(currentView, nodeView)
    
    // 3. 执行分配变更
    changes := b.computeChanges(currentView, expectedLayout)
    if len(changes) > 0 {
        if err := b.applyChanges(ctx, changes); err != nil {
            log.Warn("apply balance changes failed", zap.Error(err))
            return
        }
    }
    
    b.lastRebalanceTime = time.Now()
}
```

### 5.2 变更计算

```go
type BalanceChange struct {
    ChannelID ChannelID
    From      int64  // 源节点
    To        int64  // 目标节点
}

func (b *balancerImpl) computeChanges(
    current *PChannelView,
    expected ExpectedLayout) []BalanceChange {
    
    var changes []BalanceChange
    
    for channelID, expectedNode := range expected.Assignments {
        currentChannel := current.Channels[channelID]
        
        // 需要重新分配
        if currentChannel.CurrentServerID() != expectedNode {
            changes = append(changes, BalanceChange{
                ChannelID: channelID,
                From:      currentChannel.CurrentServerID(),
                To:        expectedNode,
            })
        }
    }
    
    // 限制每次变更数量
    if len(changes) > b.config.MaxChangesPerRound {
        changes = changes[:b.config.MaxChangesPerRound]
    }
    
    return changes
}
```

### 5.3 变更应用

```go
func (b *balancerImpl) applyChanges(
    ctx context.Context,
    changes []BalanceChange) error {
    
    // 1. 构建更新批次
    updates := make(map[ChannelID]*types.PChannelInfoAssigned)
    
    for _, change := range changes {
        channel := b.channelManager.GetChannel(change.ChannelID)
        node := b.nodeManager.GetNode(change.To)
        
        updates[change.ChannelID] = &types.PChannelInfoAssigned{
            Channel: channel.ChannelInfo(),
            Node:    node.ToStreamingNodeInfo(),
        }
    }
    
    // 2. 应用更新
    if err := b.channelManager.AssignPChannels(ctx, updates); err != nil {
        return err
    }
    
    // 3. 通知相关节点
    for _, change := range changes {
        // 通知源节点释放 Channel
        if change.From > 0 {
            b.notifyNodeReleaseChannel(change.From, change.ChannelID)
        }
        
        // 通知目标节点接管 Channel
        b.notifyNodeAssignChannel(change.To, change.ChannelID)
    }
    
    return nil
}
```

## 6. 协调通信机制

### 6.1 Assignment Discovery

```go
type AssignmentDiscoverServer struct {
    balancer Balancer
    stream   AssignmentService_AssignmentDiscoverServer
}

func (s *AssignmentDiscoverServer) Execute() error {
    // 1. 发送初始分配
    initialView := s.getCurrentAssignments()
    if err := s.sendAssignments(initialView); err != nil {
        return err
    }
    
    // 2. 监听分配变更
    return s.balancer.WatchChannelAssignments(
        s.stream.Context(),
        func(version VersionInt64Pair, assignments []PChannelInfoAssigned) error {
            // 发送增量更新
            return s.sendAssignments(AssignmentView{
                Version:     version,
                Assignments: assignments,
            })
        })
}
```

### 6.2 客户端同步

```go
type AssignmentWatcher struct {
    client      AssignmentServiceClient
    assignments sync.Map // channelID -> assignment
    callbacks   []func(assignments map[string]PChannelInfoAssigned)
}

func (w *AssignmentWatcher) Start(ctx context.Context) error {
    stream, err := w.client.AssignmentDiscover(ctx)
    if err != nil {
        return err
    }
    
    for {
        resp, err := stream.Recv()
        if err != nil {
            return err
        }
        
        // 更新本地缓存
        for _, assignment := range resp.Assignments {
            w.assignments.Store(assignment.Channel.Name, assignment)
        }
        
        // 通知回调
        w.notifyCallbacks()
    }
}
```

## 7. 弹性伸缩

### 7.1 自动扩缩容

```go
type AutoScaler struct {
    balancer      Balancer
    nodeManager   NodeManager
    scaleExecutor ScaleExecutor
    
    config AutoScaleConfig
}

type AutoScaleConfig struct {
    MinNodes            int
    MaxNodes            int
    ScaleUpThreshold    float64  // CPU/内存使用率
    ScaleDownThreshold  float64
    CooldownPeriod      time.Duration
}

func (as *AutoScaler) checkScaling() {
    metrics := as.collectMetrics()
    
    // 扩容检查
    if metrics.AvgCPUUsage > as.config.ScaleUpThreshold ||
       metrics.AvgMemoryUsage > as.config.ScaleUpThreshold {
        
        if as.canScaleUp() {
            as.scaleUp()
        }
    }
    
    // 缩容检查
    if metrics.AvgCPUUsage < as.config.ScaleDownThreshold &&
       metrics.AvgMemoryUsage < as.config.ScaleDownThreshold {
        
        if as.canScaleDown() {
            as.scaleDown()
        }
    }
}
```

### 7.2 平滑迁移

```go
func (b *balancerImpl) gracefulMigration(
    ctx context.Context,
    channelID ChannelID,
    fromNode, toNode int64) error {
    
    // 1. 通知目标节点准备
    if err := b.prepareTargetNode(ctx, toNode, channelID); err != nil {
        return err
    }
    
    // 2. 等待目标节点就绪
    if err := b.waitTargetNodeReady(ctx, toNode, channelID); err != nil {
        return err
    }
    
    // 3. 切换流量
    if err := b.switchTraffic(ctx, channelID, fromNode, toNode); err != nil {
        return err
    }
    
    // 4. 清理源节点
    return b.cleanupSourceNode(ctx, fromNode, channelID)
}
```

## 8. 调度优化

### 8.1 批量调度

```go
type BatchScheduler struct {
    pendingChanges []BalanceChange
    batchSize      int
    flushInterval  time.Duration
}

func (bs *BatchScheduler) Schedule(change BalanceChange) {
    bs.mu.Lock()
    bs.pendingChanges = append(bs.pendingChanges, change)
    
    if len(bs.pendingChanges) >= bs.batchSize {
        bs.flush()
    }
    bs.mu.Unlock()
}

func (bs *BatchScheduler) flush() {
    if len(bs.pendingChanges) == 0 {
        return
    }
    
    // 优化调度顺序
    optimized := bs.optimizeSchedule(bs.pendingChanges)
    
    // 执行批量调度
    bs.executeBatch(optimized)
    
    bs.pendingChanges = nil
}
```

### 8.2 调度优先级

```go
type PriorityScheduler struct {
    queues map[Priority]*list.List
}

type Priority int

const (
    PriorityHigh   Priority = 0
    PriorityNormal Priority = 1
    PriorityLow    Priority = 2
)

func (ps *PriorityScheduler) getPriority(change BalanceChange) Priority {
    // 节点故障触发的迁移 - 高优先级
    if ps.isNodeFailure(change.From) {
        return PriorityHigh
    }
    
    // 负载均衡触发的迁移 - 普通优先级
    if ps.isLoadBalance(change) {
        return PriorityNormal
    }
    
    // 优化触发的迁移 - 低优先级
    return PriorityLow
}
```

## 9. 监控与诊断

### 9.1 调度指标

```go
type SchedulerMetrics struct {
    // 调度次数
    ScheduleCount prometheus.Counter
    
    // 调度延迟
    ScheduleLatency prometheus.Histogram
    
    // 迁移成功率
    MigrationSuccessRate prometheus.Gauge
    
    // 负载均衡度
    BalanceScore prometheus.Gauge
}
```

### 9.2 调度追踪

```go
type ScheduleTrace struct {
    TraceID   string
    Timestamp time.Time
    Action    string
    Details   map[string]interface{}
}

func (b *balancerImpl) traceSchedule(action string, details map[string]interface{}) {
    trace := ScheduleTrace{
        TraceID:   uuid.New().String(),
        Timestamp: time.Now(),
        Action:    action,
        Details:   details,
    }
    
    // 记录到日志
    log.Info("schedule trace", 
        zap.String("traceID", trace.TraceID),
        zap.String("action", action),
        zap.Any("details", details))
}
```

## 10. 最佳实践

### 10.1 调度参数配置

```yaml
balancer:
  # 检查间隔
  checkInterval: 30s
  
  # 重平衡阈值
  rebalanceThreshold: 0.2
  
  # 每轮最大变更数
  maxChangesPerRound: 10
  
  # 冷却期
  cooldownPeriod: 5m
```

### 10.2 调度策略选择

1. **稳定优先**：增加亲和性权重，减少迁移
2. **性能优先**：快速响应负载变化，积极迁移
3. **成本优先**：最小化资源使用，支持缩容

### 10.3 故障场景处理

1. **节点故障**：立即触发重调度
2. **网络分区**：等待恢复，避免频繁迁移
3. **过载保护**：限流和降级策略