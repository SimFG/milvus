# Milvus Segcore 数据存储和管理机制

## 1. 存储架构概述

Milvus 的存储系统采用分层架构设计，支持多种存储后端，实现了数据的高效存储、读取和管理。

### 1.1 核心组件

```
存储层架构
├── ChunkManager (存储管理器)
│   ├── LocalChunkManager
│   ├── MinioChunkManager
│   ├── AzureChunkManager
│   └── GcpNativeChunkManager
├── DataCodec (数据编解码)
│   ├── PayloadWriter
│   └── PayloadReader
├── Chunk (数据块)
│   ├── FixedWidthChunk
│   ├── StringChunk
│   ├── SparseFloatVectorChunk
│   └── ArrayChunk
└── Binlog (二进制日志)
    ├── InsertBinlog
    ├── DeleteBinlog
    └── IndexBinlog
```

### 1.2 存储格式

Milvus 使用了多种存储格式：
- **Binlog 格式**：用于存储插入和删除日志
- **Parquet 格式**：用于列式存储，支持高效压缩
- **原始二进制格式**：用于索引数据
- **Mmap 格式**：支持内存映射的数据格式

## 2. ChunkManager 存储管理器

### 2.1 ChunkManager 接口

```cpp
class ChunkManager {
public:
    // 文件操作
    virtual bool Exist(const std::string& filepath) = 0;
    virtual uint64_t Size(const std::string& filepath) = 0;
    
    // 读写操作
    virtual uint64_t Read(const std::string& filepath, void* buf, uint64_t len) = 0;
    virtual void Write(const std::string& filepath, void* buf, uint64_t len) = 0;
    
    // 带偏移的读写
    virtual uint64_t Read(const std::string& filepath, uint64_t offset, 
                         void* buf, uint64_t len) = 0;
    virtual void Write(const std::string& filepath, uint64_t offset, 
                      void* buf, uint64_t len) = 0;
    
    // 文件管理
    virtual std::vector<std::string> ListWithPrefix(const std::string& filepath) = 0;
    virtual void Remove(const std::string& filepath) = 0;
};
```

### 2.2 存储后端实现

#### 2.2.1 LocalChunkManager
- 基于本地文件系统
- 直接使用标准文件 I/O
- 适用于单机部署

#### 2.2.2 MinioChunkManager
- 基于 MinIO 对象存储
- 支持 S3 兼容的 API
- 适用于分布式部署
- 支持多副本和容错

#### 2.2.3 云存储管理器
- **AzureChunkManager**：Azure Blob Storage
- **GcpNativeChunkManager**：Google Cloud Storage
- **OpenDALChunkManager**：统一的存储访问层

### 2.3 存储路径管理

```
bucket/
├── insert_log/
│   ├── segment_id/
│   │   ├── field_id/
│   │   │   ├── 0
│   │   │   ├── 1
│   │   │   └── ...
├── delta_log/
│   └── segment_id/
│       └── delete_log
└── index_files/
    └── segment_id/
        └── field_id/
            └── index_type/
                ├── index_data
                └── index_meta
```

## 3. 数据编解码系统

### 3.1 DataCodec 架构

```cpp
class DataCodec {
protected:
    CodecType codec_type_;
    std::pair<Timestamp, Timestamp> time_range_;
    std::shared_ptr<PayloadReader> payload_reader_;
    
public:
    virtual std::vector<uint8_t> Serialize(StorageType medium) = 0;
    virtual void SetFieldDataMeta(const FieldDataMeta& meta) = 0;
};
```

### 3.2 PayloadWriter

用于将内存数据序列化为存储格式：

```cpp
class PayloadWriter {
private:
    DataType column_type_;
    bool nullable_;
    std::shared_ptr<arrow::ArrayBuilder> builder_;
    std::shared_ptr<arrow::Schema> schema_;
    std::shared_ptr<PayloadOutputStream> output_;
    
public:
    void add_payload(const Payload& raw_data);
    void finish();
    const std::vector<uint8_t>& get_payload_buffer() const;
};
```

序列化流程：
1. 根据数据类型创建 Arrow ArrayBuilder
2. 批量添加数据到 builder
3. 构建 Arrow RecordBatch
4. 使用 Parquet Writer 写入数据

### 3.3 PayloadReader

用于从存储格式反序列化数据：

```cpp
class PayloadReader {
public:
    DataType get_payload_datatype() const;
    int64_t get_payload_size() const;
    FieldDataPtr get_field_data() const;
    const uint8_t* get_payload_data() const;
};
```

反序列化流程：
1. 读取元数据，确定数据类型和大小
2. 根据存储格式选择解析方式
3. 转换为内存中的 FieldData 结构

## 4. Chunk 数据块管理

### 4.1 Chunk 基类

```cpp
class Chunk {
protected:
    char* data_;
    int64_t row_nums_;
    uint64_t size_;
    bool nullable_;
    FixedVector<bool> valid_;  // 空值位图
    
public:
    virtual const char* ValueAt(int64_t idx) const = 0;
    virtual bool isValid(int offset);
};
```

### 4.2 具体实现

#### 4.2.1 FixedWidthChunk
用于固定长度数据（数值类型、定长向量）：
- 连续内存布局
- O(1) 随机访问
- 支持 SIMD 优化

#### 4.2.2 StringChunk
用于变长字符串：
```cpp
class StringChunk : public Chunk {
    uint32_t* offsets_;  // 偏移数组
    // 数据布局：[null_bitmap][offsets][string_data]
};
```

#### 4.2.3 ArrayChunk
用于数组类型：
- 支持嵌套结构
- 使用 Arrow Array 格式
- 支持复杂数据类型

### 4.3 内存映射支持

```cpp
// Mmap 数据加载
char* data = mmap(nullptr, file_size, PROT_READ, MAP_PRIVATE, fd, 0);
auto chunk = std::make_unique<FixedWidthChunk>(
    row_nums, dim, data, file_size, sizeof(float), nullable);
```

优点：
- 减少内存占用
- 延迟加载
- 利用操作系统缓存

## 5. Binlog 二进制日志

### 5.1 Binlog 格式

```
Binlog 文件结构：
├── MagicNumber (4 bytes)
├── DescriptorEvent
│   ├── EventType
│   ├── EventLength
│   └── Payload
├── InsertEvent/DeleteEvent
│   ├── EventType
│   ├── EventLength
│   ├── StartTimestamp
│   ├── EndTimestamp
│   └── Payload
└── ... 更多事件
```

### 5.2 BinlogReader

```cpp
class BinlogReader {
    std::shared_ptr<uint8_t[]> data_;
    int64_t size_;
    int64_t tell_;  // 当前读取位置
    
public:
    template <typename T>
    SegcoreError ReadSingleValue(T& val);
    SegcoreError Read(int64_t nbytes, void* out);
};
```

### 5.3 事件类型

- **InsertEvent**：插入数据事件
- **DeleteEvent**：删除数据事件
- **CreateCollectionEvent**：创建集合事件
- **DropCollectionEvent**：删除集合事件
- **IndexFileEvent**：索引文件事件

## 6. 存储优化技术

### 6.1 数据压缩

支持多种压缩算法：
- **Snappy**：快速压缩，适合实时场景
- **Zstd**：高压缩比，适合冷数据
- **LZ4**：极快压缩速度

### 6.2 批量 I/O

```cpp
// 批量读取多个文件
std::vector<std::future<FileDataPtr>> futures;
for (const auto& file : files) {
    futures.push_back(thread_pool->enqueue([&] {
        return ReadFile(file);
    }));
}
```

### 6.3 缓存机制

#### 6.3.1 ChunkCache
```cpp
class ChunkCache {
    std::shared_mutex mutex_;
    std::unordered_map<std::string, ChunkPtr> cache_;
    std::atomic<size_t> capacity_;
    
public:
    ChunkPtr Get(const std::string& key);
    void Insert(const std::string& key, ChunkPtr chunk);
};
```

#### 6.3.2 缓存策略
- LRU 淘汰策略
- 预读取机制
- 热点数据识别

### 6.4 并发控制

- 读写锁分离
- 细粒度锁
- 无锁数据结构（部分场景）

## 7. 文件管理

### 7.1 FileManager

```cpp
class FileManager {
public:
    // 批量操作
    std::vector<FieldDataPtr> CacheRawDataToMemory(
        const std::vector<std::string>& files);
    
    // 索引管理
    void AddFile(const BinarySet& binary_set);
    std::map<std::string, FileDataPtr> LoadIndexToMemory(
        const std::vector<std::string>& files);
};
```

### 7.2 文件分片

大文件分片策略：
```cpp
// 文件分片元信息
struct SliceMeta {
    std::string name;
    int slice_num;
    size_t total_len;
};

// 生成分片文件名
std::string GenSlicedFileName(const std::string& prefix, int slice_id);
```

## 8. 数据一致性保证

### 8.1 时间戳管理

每个数据操作都有时间戳：
- 插入时间戳
- 删除时间戳
- 用于 MVCC 控制

### 8.2 原子性操作

- 使用临时文件 + 重命名
- 事务日志
- 检查点机制

### 8.3 容错机制

- 数据校验和
- 副本管理
- 故障恢复

## 9. 性能监控

### 9.1 存储指标

```cpp
struct StorageMetrics {
    std::atomic<size_t> bytes_written;
    std::atomic<size_t> bytes_read;
    std::atomic<size_t> file_count;
    std::atomic<double> write_latency;
    std::atomic<double> read_latency;
};
```

### 9.2 监控点

- I/O 吞吐量
- 延迟分布
- 缓存命中率
- 压缩比

## 10. 最佳实践

### 10.1 存储配置

1. **本地存储**
   - SSD 优于 HDD
   - 考虑 RAID 配置
   - 预留足够空间

2. **对象存储**
   - 配置合适的并发度
   - 使用分片上传
   - 启用服务端加密

### 10.2 性能调优

1. **缓存调优**
   - 根据内存大小调整缓存容量
   - 监控缓存命中率
   - 定期清理过期数据

2. **I/O 调优**
   - 批量操作减少请求次数
   - 异步 I/O 提高并发
   - 预读取优化顺序访问

3. **压缩策略**
   - 热数据使用快速压缩
   - 冷数据使用高压缩比
   - 平衡 CPU 和存储开销