# Milvus Segcore 核心请求处理流程

## 1. 数据插入流程

### 1.1 Growing Segment 插入流程

数据插入主要发生在 Growing Segment 中，具体流程如下：

#### 第一步：预分配空间 (PreInsert)
```cpp
int64_t SegmentGrowingImpl::PreInsert(int64_t size) {
    auto reserved_begin = insert_record_.reserved.fetch_add(size);
    return reserved_begin;
}
```
- 原子操作分配连续的空间
- 返回预留空间的起始偏移量

#### 第二步：插入数据 (Insert)
```cpp
void SegmentGrowingImpl::Insert(int64_t reserved_offset,
                               int64_t num_rows,
                               const int64_t* row_ids,
                               const Timestamp* timestamps_raw,
                               const InsertRecordProto* insert_record_proto)
```

详细步骤：
1. **数据验证**
   - 检查插入数据的有效性
   - 构建 field_id 到数据偏移的映射

2. **时间戳处理**
   - 将时间戳写入 `insert_record_.timestamps_`
   - Query Node 已保证时间戳有序

3. **字段数据写入**
   - 遍历所有字段，将数据写入对应的 ConcurrentVector
   - 处理可空字段的 valid_data
   - 更新内存使用统计

4. **索引更新**
   - 如果启用了临时段索引，更新向量索引
   - 为文本字段构建全文索引（如果启用）
   - 为 JSON 字段构建索引（如果启用）

5. **主键更新**
   - 将主键值与偏移量的映射关系写入 `pk2offset_`
   - 更新 ack_responder 确认数据已插入

### 1.2 数据加载流程 (LoadFieldData)

用于批量加载数据到 Growing Segment：

```cpp
void SegmentGrowingImpl::LoadFieldData(const LoadFieldDataInfo& info)
```

- 支持批量加载多个字段的数据
- 自动构建相应的索引
- 更新统计信息

## 2. 查询执行流程

### 2.1 向量搜索流程 (Search)

```cpp
std::unique_ptr<SearchResult> SegmentInternalInterface::Search(
    const query::Plan* plan,
    const query::PlaceholderGroup* placeholder_group,
    Timestamp timestamp,
    int32_t consistency_level,
    Timestamp collection_ttl) const
```

执行步骤：
1. **获取读锁**
   - 使用 shared_lock 保证并发读

2. **查询计划执行**
   - 创建 `ExecPlanNodeVisitor` 访问者
   - 遍历执行计划节点树
   - 根据节点类型执行相应操作

3. **搜索策略选择**
   - Growing Segment：使用 `SearchOnGrowing`
   - Sealed Segment：使用 `SearchOnSealed` 或 `SearchOnIndex`

4. **过滤处理**
   - 时间戳过滤：过滤掉时间戳大于查询时间戳的数据
   - 删除过滤：过滤掉已删除的数据
   - 标量过滤：执行表达式计算

5. **结果组装**
   - 填充主键信息
   - 填充目标字段数据
   - 返回 SearchResult

### 2.2 数据检索流程 (Retrieve)

```cpp
std::unique_ptr<proto::segcore::RetrieveResults> 
SegmentInternalInterface::Retrieve(
    tracer::TraceContext* trace_ctx,
    const query::RetrievePlan* plan,
    Timestamp timestamp,
    int64_t limit_size,
    bool ignore_non_pk,
    int32_t consistency_level,
    Timestamp collection_ttl) const
```

执行步骤：
1. **执行查询计划**
   - 通过 ExecPlanNodeVisitor 执行
   - 获取满足条件的行偏移量

2. **数据量检查**
   - 计算输出数据大小
   - 确保不超过 limit_size

3. **数据提取**
   - 使用 `bulk_subscript` 批量提取数据
   - 填充所有请求的字段

4. **特殊处理**
   - COUNT 查询：直接返回计数结果
   - 普通查询：返回具体数据

## 3. 删除操作流程

### 3.1 删除记录 (Delete)

```cpp
SegcoreError SegmentGrowingImpl::Delete(
    int64_t reserved_offset,
    int64_t size,
    const IdArray* pks,
    const Timestamp* timestamps)
```

执行步骤：
1. **主键解析**
   - 从 IdArray 解析出主键值
   - 支持 INT64 和 VARCHAR 类型主键

2. **存在性检查**
   - 过滤掉不存在的主键
   - 只处理实际存在的删除请求

3. **删除记录更新**
   - 将删除信息写入 `deleted_record_`
   - 记录删除的主键和时间戳

4. **内存统计更新**
   - 更新删除记录占用的内存大小

### 3.2 删除过滤机制

在查询时应用删除过滤：
```cpp
void SegmentGrowingImpl::mask_with_delete(
    BitsetTypeView& bitset,
    int64_t ins_barrier,
    Timestamp timestamp) const
```

- 根据查询时间戳过滤已删除的数据
- 使用 BitSet 标记删除的位置

## 4. 执行引擎详解

### 4.1 表达式计算

表达式类型包括：
- **比较表达式**：CompareExpr（等于、大于、小于等）
- **范围表达式**：BinaryRangeExpr、UnaryRangeExpr
- **逻辑表达式**：LogicalBinaryExpr、LogicalUnaryExpr
- **存在性表达式**：ExistsExpr
- **JSON 表达式**：JsonContainsExpr
- **函数调用**：CallExpr

### 4.2 执行算子

主要算子类型：
- **VectorSearchNode**：向量搜索算子
- **FilterBitsNode**：位图过滤算子
- **MvccNode**：多版本并发控制算子
- **GroupByNode**：分组算子
- **CountNode**：计数算子

### 4.3 执行优化

1. **批处理优化**
   - 使用 bulk_subscript 批量读取数据
   - 减少内存拷贝

2. **并发优化**
   - 使用读写锁控制并发
   - ConcurrentVector 支持并发插入

3. **内存优化**
   - 及时释放不需要的 chunk 数据
   - 使用内存池减少分配开销

## 5. 一致性保证

### 5.1 时间戳机制
- 每条数据都有唯一的时间戳
- 查询时只能看到时间戳小于等于查询时间戳的数据

### 5.2 一致性级别
- Strong：查询最新的数据
- Eventually：允许一定的延迟
- Bounded：在指定时间范围内的一致性

### 5.3 MVCC 实现
- 通过时间戳实现多版本并发控制
- 删除操作不立即物理删除，而是标记删除
- 查询时根据时间戳过滤数据