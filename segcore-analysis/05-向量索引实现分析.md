# Milvus Segcore 向量索引实现分析

## 1. 向量索引概述

Milvus 的向量索引系统基于 Knowhere 库实现，支持多种向量索引类型和搜索算法。向量索引是 Milvus 实现高效相似性搜索的核心组件。

### 1.1 核心类层次结构

```
IndexBase
  └── VectorIndex (抽象基类)
        ├── VectorMemIndex<T> (内存索引)
        └── VectorDiskIndex<T> (磁盘索引)
```

### 1.2 支持的数据类型

- **VECTOR_FLOAT**: 32位浮点向量
- **VECTOR_FLOAT16**: 16位浮点向量
- **VECTOR_BFLOAT16**: Brain Float 16位向量
- **VECTOR_BINARY**: 二进制向量
- **VECTOR_SPARSE_FLOAT**: 稀疏浮点向量

## 2. VectorIndex 接口设计

### 2.1 核心接口定义

```cpp
class VectorIndex : public IndexBase {
public:
    // 查询接口
    virtual void Query(const DatasetPtr dataset,
                      const SearchInfo& search_info,
                      const BitsetView& bitset,
                      SearchResult& search_result) const = 0;
    
    // 向量迭代器接口
    virtual knowhere::expected<std::vector<knowhere::IndexNode::IteratorPtr>>
    VectorIterators(const DatasetPtr dataset,
                    const knowhere::Json& json,
                    const BitsetView& bitset) const;
    
    // 获取原始数据
    virtual const bool HasRawData() const = 0;
    virtual std::vector<uint8_t> GetVector(const DatasetPtr dataset) const = 0;
    
    // 索引元信息
    IndexType GetIndexType() const;
    MetricType GetMetricType() const;
    int64_t GetDim() const;
};
```

### 2.2 距离度量类型

Milvus 支持多种距离度量方式：
- **L2** (欧氏距离): 适用于浮点向量
- **IP** (内积): 适用于浮点向量
- **COSINE** (余弦相似度): 适用于浮点向量
- **HAMMING** (汉明距离): 适用于二进制向量
- **JACCARD** (杰卡德距离): 适用于二进制向量

## 3. VectorMemIndex 实现

### 3.1 构造与初始化

```cpp
template <typename T>
VectorMemIndex<T>::VectorMemIndex(
    const IndexType& index_type,
    const MetricType& metric_type,
    const IndexVersion& version,
    bool use_knowhere_build_pool,
    const storage::FileManagerContext& file_manager_context)
```

初始化步骤：
1. 检查度量类型兼容性
2. 验证索引类型与度量类型的组合
3. 创建文件管理器（如果需要）
4. 通过 Knowhere 工厂创建底层索引对象

### 3.2 索引构建

#### 3.2.1 从数据集构建
```cpp
void VectorMemIndex<T>::BuildWithDataset(const DatasetPtr& dataset,
                                        const Config& config)
```

构建流程：
1. 更新索引配置
2. 设置向量维度
3. 调用 Knowhere 的 Build 方法
4. 支持使用 Knowhere 的线程池进行并行构建

#### 3.2.2 从文件构建
```cpp
void VectorMemIndex<T>::Build(const Config& config)
```

文件构建流程：
1. 从配置中获取插入文件路径
2. 使用文件管理器加载原始数据到内存
3. 处理可选的标量字段（用于混合搜索）
4. 合并多个数据文件
5. 创建数据集并构建索引

### 3.3 查询执行

```cpp
void VectorMemIndex<T>::Query(const DatasetPtr dataset,
                             const SearchInfo& search_info,
                             const BitsetView& bitset,
                             SearchResult& search_result) const
```

查询流程：
1. **参数准备**
   - 提取查询数量和 topk
   - 准备搜索配置

2. **搜索类型选择**
   - 范围搜索：使用 RangeSearch
   - TopK 搜索：使用 Search

3. **结果处理**
   - 提取 ID 和距离
   - 应用小数位舍入（如果配置）
   - 填充搜索结果结构

### 3.4 迭代器支持

```cpp
knowhere::expected<std::vector<knowhere::IndexNode::IteratorPtr>>
VectorMemIndex<T>::VectorIterators(const DatasetPtr dataset,
                                  const knowhere::Json& conf,
                                  const BitsetView& bitset) const
```

用于支持基于迭代器的搜索，特别适用于：
- 混合搜索场景
- 需要逐步获取结果的场景
- 复杂的过滤条件

## 4. 索引持久化与加载

### 4.1 序列化

```cpp
BinarySet VectorMemIndex<T>::Serialize(const Config& config)
```

序列化步骤：
1. 调用 Knowhere 的序列化方法
2. 对二进制数据进行拆分（Disassemble）
3. 返回 BinarySet

### 4.2 加载流程

```cpp
void VectorMemIndex<T>::Load(milvus::tracer::TraceContext ctx, 
                            const Config& config)
```

加载策略：
1. **普通加载**：直接从文件加载到内存
2. **Mmap 加载**：使用内存映射减少内存占用
3. **分片加载**：支持大索引的分片并行加载

加载优化：
- 批量加载多个分片
- 并行读取文件
- 延迟组装索引数据

## 5. 向量索引在 Segcore 中的集成

### 5.1 Growing Segment 中的向量索引

Growing Segment 支持实时构建向量索引：

```cpp
if (segcore_config_.get_enable_interim_segment_index()) {
    indexing_record_.AppendingIndex(
        reserved_offset,
        num_rows,
        field_id,
        field_data,
        insert_record_);
}
```

特点：
- 增量构建
- 支持小批量索引
- 可配置是否启用

### 5.2 Sealed Segment 中的向量索引

Sealed Segment 使用预构建的向量索引：
- 从存储加载完整索引
- 支持 mmap 方式加载大索引
- 索引不可变，优化查询性能

### 5.3 查询执行优化

#### 5.3.1 位图过滤
```cpp
auto res = index_.Search(dataset, search_conf, bitset);
```
- 使用 BitsetView 过滤已删除或不满足条件的向量
- 在 Knowhere 层面进行过滤，减少无效计算

#### 5.3.2 批量查询
- 支持多个查询向量的批量处理
- 内部优化内存访问模式
- 利用 SIMD 指令加速

## 6. 特殊向量类型支持

### 6.1 稀疏向量

```cpp
std::unique_ptr<const knowhere::sparse::SparseRow<float>[]>
GetSparseVector(const DatasetPtr dataset) const
```

稀疏向量特点：
- 使用 SparseRow 格式存储
- 支持高维稀疏数据
- 优化存储和计算效率

### 6.2 二进制向量

二进制向量使用特殊的距离计算：
- Hamming 距离
- Jaccard 距离
- 使用位运算优化

### 6.3 Float16 支持

支持半精度浮点数：
- 减少内存占用
- 提高缓存利用率
- 可能损失一定精度

## 7. 性能优化技术

### 7.1 并行化
- 使用 Knowhere 的构建线程池
- 多线程并行搜索
- 并行文件加载

### 7.2 内存优化
- Mmap 支持减少内存占用
- 延迟加载策略
- 内存池复用

### 7.3 缓存优化
- 热点数据缓存
- 索引元数据缓存
- 查询结果缓存

### 7.4 SIMD 优化
- Knowhere 底层使用 SIMD 指令
- 向量化距离计算
- 批量操作优化

## 8. Knowhere 集成

### 8.1 索引类型映射

Milvus 索引类型到 Knowhere 的映射：
- IVF_FLAT → knowhere::IndexEnum::IVF_FLAT
- IVF_SQ8 → knowhere::IndexEnum::IVF_SQ8
- IVF_PQ → knowhere::IndexEnum::IVF_PQ
- HNSW → knowhere::IndexEnum::HNSW
- DISKANN → knowhere::IndexEnum::DISKANN

### 8.2 配置传递

```cpp
knowhere::Json search_conf = PrepareSearchParams(search_info);
```

配置参数包括：
- nprobe: IVF 索引的搜索参数
- ef: HNSW 的搜索参数
- search_list: DiskANN 的搜索参数

## 9. 错误处理

### 9.1 构建错误
```cpp
if (stat != knowhere::Status::success)
    PanicInfo(ErrorCode::IndexBuildError,
              "failed to build index, " + KnowhereStatusString(stat));
```

### 9.2 查询错误
- 检查返回状态
- 提供详细错误信息
- 支持错误恢复

## 10. 未来优化方向

1. **GPU 加速**
   - 支持 GPU 索引构建和查询
   - CPU-GPU 异构计算

2. **动态索引**
   - 支持索引的动态更新
   - 减少重建开销

3. **压缩技术**
   - 更激进的量化方法
   - 自适应压缩策略

4. **分布式索引**
   - 跨节点的索引分片
   - 分布式查询优化