# Milvus Segcore 标量索引建立过程

## 1. 标量索引概述

Milvus 支持多种标量索引类型，用于加速标量字段的查询操作。主要的标量索引类型包括：

### 1.1 索引类型枚举
```cpp
enum class ScalarIndexType {
    NONE = 0,
    BITMAP,      // 位图索引
    STLSORT,     // 基于 STL sort 的排序索引
    MARISA,      // Marisa Trie（用于字符串）
    INVERTED,    // 倒排索引（基于 Tantivy）
    HYBRID,      // 混合索引
};
```

### 1.2 索引选择策略

根据数据类型和索引类型，IndexFactory 会创建相应的索引：
- **数值类型**（Int8/16/32/64, Float, Double）：默认使用 STLSort，可选 Bitmap、Inverted、Hybrid
- **字符串类型**：默认使用 Marisa Trie，可选 Bitmap、Inverted、Hybrid
- **布尔类型**：特殊处理，使用 BoolIndex

## 2. 索引创建流程

### 2.1 索引工厂（IndexFactory）

```cpp
template <typename T>
ScalarIndexPtr<T> IndexFactory::CreatePrimitiveScalarIndex(
    const CreateIndexInfo& create_index_info,
    const storage::FileManagerContext& file_manager_context)
```

索引创建步骤：
1. 根据 `create_index_info.index_type` 确定索引类型
2. 创建对应的索引实例
3. 传入文件管理器上下文用于持久化

### 2.2 索引构建过程

以 ScalarIndexSort 为例，详细说明索引构建过程：

#### 步骤 1：索引初始化
```cpp
ScalarIndexSort<T>::ScalarIndexSort(
    const storage::FileManagerContext& file_manager_context)
    : ScalarIndex<T>(ASCENDING_SORT), is_built_(false), data_()
```

#### 步骤 2：数据构建
```cpp
void ScalarIndexSort<T>::Build(size_t n, const T* values, const bool* valid_data)
```

构建流程：
1. **数据预处理**
   - 预留空间：`data_.reserve(n)`
   - 初始化有效性位图：`valid_bitset_ = TargetBitmap(total_num_rows_, false)`
   - 初始化索引映射：`idx_to_offsets_.resize(n)`

2. **数据索引化**
   - 遍历所有数据，创建 IndexStructure（值-偏移量对）
   - 处理空值：根据 valid_data 标记有效数据

3. **排序优化**
   - 使用 `std::sort` 对数据进行排序
   - 构建反向映射：原始偏移量到排序后位置的映射

#### 步骤 3：批量构建（从 FieldData）
```cpp
void ScalarIndexSort<T>::BuildWithFieldData(
    const std::vector<milvus::FieldDataPtr>& field_datas)
```

这种方式支持从多个数据块批量构建索引，特别适用于 Sealed Segment。

## 3. 各种索引类型详解

### 3.1 STLSort 索引

**原理**：基于 STL 排序的有序数组索引

**数据结构**：
```cpp
struct IndexStructure {
    T a_;        // 值
    int32_t idx_;  // 原始偏移量
};
```

**查询实现**：
- **In 查询**：使用二分查找（lower_bound/upper_bound）
- **Range 查询**：找到范围边界，返回范围内的所有元素
- **NotIn 查询**：先设置所有位为 true，然后将匹配的位设为 false

**优点**：
- 实现简单，查询效率高
- 支持范围查询
- 内存占用相对较小

### 3.2 Bitmap 索引

**原理**：为每个唯一值维护一个位图，记录该值出现的位置

**数据结构**：
```cpp
std::map<T, roaring::Roaring> bitmaps_;  // 值到位图的映射
TargetBitmap null_bitmap_;                // 空值位图
```

**构建过程**：
1. 遍历所有数据
2. 为每个唯一值创建或更新对应的 Roaring Bitmap
3. 记录空值位置

**查询实现**：
- **In 查询**：合并多个值对应的位图
- **Range 查询**：合并范围内所有值的位图
- **Equal 查询**：直接返回对应值的位图

**优点**：
- 对于低基数列（唯一值少）效率极高
- 支持快速的集合操作（AND、OR、NOT）

### 3.3 Inverted 索引（基于 Tantivy）

**原理**：使用 Tantivy（Rust 实现的全文搜索引擎）构建倒排索引

**特点**：
- 支持全文搜索
- 支持复杂的查询语法
- 特别适合字符串字段

**构建过程**：
1. 初始化 Tantivy 索引写入器
2. 为每个文档（行）创建索引项
3. 提交索引到磁盘

### 3.4 Hybrid 索引

**原理**：结合多种索引的优点，根据查询类型选择最优索引

**组成**：
- Bitmap 索引：用于等值查询和 IN 查询
- STLSort 索引：用于范围查询
- Inverted 索引：用于文本搜索

**查询策略**：
```cpp
switch (op_type) {
    case OpType::In:
    case OpType::NotIn:
        return bitmap_index_->Query(dataset);
    case OpType::Range:
        return sort_index_->Query(dataset);
    case OpType::Match:
        return inverted_index_->Query(dataset);
}
```

### 3.5 Marisa Trie（字符串专用）

**原理**：使用 Marisa（静态字典树）存储字符串

**优点**：
- 空间效率高，特别适合存储大量字符串
- 支持前缀查询
- 查询速度快

## 4. 索引在 Growing Segment 中的应用

### 4.1 增量索引构建

在 Growing Segment 中，索引是增量构建的：

```cpp
void SegmentGrowingImpl::Insert(...) {
    // ... 插入数据
    if (segcore_config_.get_enable_interim_segment_index()) {
        indexing_record_.AppendingIndex(
            reserved_offset,
            num_rows,
            field_id,
            &insert_record_proto->fields_data(data_offset),
            insert_record_);
    }
}
```

### 4.2 Chunk 级别索引

Growing Segment 将数据分成多个 chunk，每个 chunk 可以独立构建索引：
- 每个 chunk 默认包含一定数量的行（可配置）
- 当 chunk 填满后，触发索引构建
- 查询时并行搜索多个 chunk 的索引

## 5. 索引持久化与加载

### 5.1 序列化

```cpp
BinarySet ScalarIndexSort<T>::Serialize(const Config& config) {
    BinarySet res_set;
    res_set.Append("index_data", index_data, index_data_size);
    res_set.Append("index_length", index_length, sizeof(size_t));
    res_set.Append("index_num_rows", index_num_rows, sizeof(size_t));
    return res_set;
}
```

### 5.2 加载

```cpp
void ScalarIndexSort<T>::Load(const BinarySet& index_binary, const Config& config) {
    // 从 BinarySet 中恢复索引数据
    // 重建内存中的数据结构
}
```

### 5.3 Mmap 支持

部分索引类型支持 mmap 加载，可以减少内存占用：
```cpp
bool IsMmapSupported() const override {
    return index_type_ == BITMAP_INDEX_TYPE ||
           index_type_ == HYBRID_INDEX_TYPE ||
           index_type_ == INVERTED_INDEX_TYPE;
}
```

## 6. 性能优化策略

### 6.1 缓存优化
- 热点数据缓存
- 查询结果缓存
- 索引元数据缓存

### 6.2 并行化
- 多线程构建索引
- 并行查询多个 chunk
- SIMD 加速（部分索引类型）

### 6.3 内存管理
- 延迟加载：按需加载索引数据
- 内存映射：大索引使用 mmap
- 及时释放：不再使用的索引及时释放内存

## 7. 索引选择建议

1. **数值类型字段**
   - 高基数：使用 STLSort 或 Hybrid
   - 低基数：使用 Bitmap
   - 需要全文搜索：使用 Inverted

2. **字符串类型字段**
   - 一般场景：使用 Marisa Trie
   - 需要全文搜索：使用 Inverted
   - 低基数：使用 Bitmap

3. **查询模式**
   - 主要是等值查询：Bitmap 或 Hybrid
   - 主要是范围查询：STLSort 或 Hybrid
   - 混合查询：Hybrid